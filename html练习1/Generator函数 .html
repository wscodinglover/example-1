<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Generator函数</title>
</head>
<body>
    <!-- 
        Generator  函数式es6提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        generator 函数可以看成一个状态机，封装了多个内部状态
        执行Generator 函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态
        形式上，generator函数式一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部都使用yield语句，定义不同的内部状态（yield语句在英语里是‘产出’）
     -->
     <script>
        function * helloWorldGenerator () {
            yield 'hello' ;
            yield 'world' ;
            return 'ending' ;
        }

        var hw = helloWorldGenerator();
        /*
            上面代码定义了一个Generator函数helloWorldGenerator,它内部有两个yield语句‘hello’和‘world’ ，即该函数有三个状态hello，world和return语句
            然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号，不同的是，调用Generator函数后该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象
        */
        /*
        下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行
        */
        hw.next()
        // {value:'hello', done:false}

        hw.next();
        // {value:'world', done:false}

        hw.next();
        // {value:'ending', done:true }

        hw.next();
        // {value:undefined,done:true}
     </script>
</body>
</html>